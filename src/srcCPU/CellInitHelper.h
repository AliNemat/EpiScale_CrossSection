/*
 * CellInitHelper.h
 *
 *  Created on: Sep 22, 2013
 *      Author: wsun2
 */

#ifndef CELLINITHELPER_H_
#define CELLINITHELPER_H_

#include <vector>
#include "GeoVector.h"
#include <cmath>
#include "commonData.h"
#include "ConfigParser.h"
#include <assert.h>
#include <time.h>
#include <stdlib.h>
#include <string>
#include "MeshGen.h"

const double numericalErrorEps = 1.0e-10;

using namespace std;

/*
 * This class helps the simulation domain to determine
 * center position of a cell and its cell type.
 */
class CellPlacementInfo {
public:
	CVector centerLocation;
	SceNodeType cellNodeType;
};

class CellInitHelper2 {
public:
	std::vector<CellPlacementInfo> obtainCentersInCircle(double radius,
			int precision, Criteria criteria);
};

struct CellInitHelperException: public std::exception {
	std::string errorMessage;
	CellInitHelperException(std::string errMsg) :
			errorMessage(errMsg) {
	}
	~CellInitHelperException() throw () {
	}
	const char* what() const throw () {
		return errorMessage.c_str();
	}
};

/**
 * Handles cell initialization.
 */
class CellInitHelper {
	SimulationType simuType;
	vector<CVector> internalBdryPts;

	CVector getPointGivenAngle(double currentAngle, double r,
			CVector centerPos);

	void generateRandomAngles(vector<double> &randomAngles,
			int initProfileNodeSize);
	void generateCellInitNodeInfo(vector<CVector> &initPos,
			std::string meshInput);
	void generateCellInitNodeInfo_v2(vector<CVector> &initPos);
	void generateECMInitNodeInfo(vector<CVector> &initECMNodePoss,
			int initNodeCountPerECM);
	void generateECMCenters(vector<CVector> &ECMCenters,
			vector<CVector> &CellCenters, vector<CVector> &bdryNodes);

	bool anyECMCenterTooClose(vector<CVector> &ecmCenters, CVector position);
	bool anyCellCenterTooClose(vector<CVector> &cellCenters, CVector position);
	bool anyBoundaryNodeTooClose(vector<CVector> &bdryNodes, CVector position);
	bool isInitNodesInitializedFlag;

	double getRandomNum(double min, double max);
	vector<CVector> generateInitCellNodes();
	vector<CVector> attemptGeenerateInitCellNodes();
	bool isPositionQualify(vector<CVector> &poss);

	void initInternalBdry();

	void initializeRawInput(RawDataInput &rawInput,
			std::vector<CVector> &cellCenterPoss);

	void transformRawCartData(CartilageRawData &cartRawData, CartPara &cartPara,
			std::vector<CVector> &initNodePos);

	bool isMXType_v2(CVector position);

	vector<CVector> rotate2D(vector<CVector> &initECMNodePoss, double angle);

	/**
	 * Used for generate RawDataInput for actual simulation purpose.
	 * The raw data generated does not only contain cell center positions but also
	 * epithelium node positions and boundary node positions.
	 * TODO: should become private someday.
	 */
	RawDataInput generateRawInputWithProfile(
			std::vector<CVector> &cellCenterPoss, bool isInnerBdryIncluded =
					true);

	/**
	 * generate simulation initialization data _v2 given raw data.
	 */
	SimulationInitData_V2 initInputsV3(RawDataInput &rawData);

	/**
	 * Used for generate RawDataInput for stabilization purpose.
	 * In order to place cells in a random domain, we need an initialization step to stabilize
	 * cell center positions which are generated by triangular mesh. It is usually difficult for
	 * triangular meshing to generate semi-evenly displaced cell centers.
	 */
	RawDataInput generateRawInput_stab();

	/**
	 * generate second version raw input data.
	 */
	RawDataInput generateRawInput_V2(std::vector<CVector> &cellCenterPoss);

	/**
	 * generate simulation initialization data given raw data.
	 */
	SimulationInitData initInputsV2(RawDataInput &rawData);

public:
	/**
	 * Default constructor is used.
	 */
	CellInitHelper();
	/**
	 * Default de-constructor is used.
	 */
	virtual ~CellInitHelper();

	/**
	 * generate simulation initialization data _v2 given raw data.
	 */
	SimulationInitData_V2 initStabInput();

	/**
	 * generate simulation initialization data _v2 given raw data.
	 */
	SimulationInitData_V2 initSimuInput(std::vector<CVector> &cellCenterPoss);
};

#endif /* CELLINITHELPER_H_ */
